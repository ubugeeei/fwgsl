use std::env;
use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    match args.get(1).map(|s| s.as_str()) {
        Some("compile") | Some("c") => {
            let file = args.get(2).unwrap_or_else(|| {
                eprintln!("Usage: fwgsl compile <file.fwgsl>");
                process::exit(1);
            });
            cmd_compile(file, args.contains(&"--emit-ast".to_string()));
        }
        Some("check") => {
            let file = args.get(2).unwrap_or_else(|| {
                eprintln!("Usage: fwgsl check <file.fwgsl>");
                process::exit(1);
            });
            cmd_check(file);
        }
        Some("fmt") => {
            let file = args.get(2).unwrap_or_else(|| {
                eprintln!("Usage: fwgsl fmt <file.fwgsl>");
                process::exit(1);
            });
            cmd_fmt(file);
        }
        Some("version") | Some("--version") | Some("-V") => {
            println!("fwgsl {}", env!("CARGO_PKG_VERSION"));
        }
        Some("help") | Some("--help") | Some("-h") | None => {
            print_help();
        }
        Some(cmd) => {
            eprintln!("Unknown command: {}", cmd);
            eprintln!();
            print_help();
            process::exit(1);
        }
    }
}

fn print_help() {
    println!(
        r#"fwgsl - Pure functional language for WebGPU

USAGE:
    fwgsl <COMMAND> [OPTIONS]

COMMANDS:
    compile, c  <file>    Compile .fwgsl to .wgsl
    check       <file>    Type-check without emitting
    fmt         <file>    Format source code
    version               Print version
    help                  Print this help

OPTIONS:
    --emit-ast            Print AST debug output
    --output, -o <file>   Output file (default: stdout)
"#
    );
}

fn cmd_compile(file: &str, emit_ast: bool) {
    let source = read_file(file);

    // Parse
    let mut parser = fwgsl_parser::parser::Parser::new(&source);
    let program = parser.parse_program();

    if emit_ast {
        println!("{:#?}", program);
        return;
    }

    // Check for parse errors
    if parser.diagnostics().has_errors() {
        print_diagnostics(
            &parser.diagnostics().iter().collect::<Vec<_>>(),
            file,
            &source,
        );
        process::exit(1);
    }

    // Semantic analysis
    let mut analyzer = fwgsl_semantic::SemanticAnalyzer::new();
    analyzer.analyze(&program);

    if analyzer.has_errors() {
        let diags: Vec<_> = analyzer.diagnostics().iter().collect();
        print_diagnostics(&diags, file, &source);
        process::exit(1);
    }

    // AST -> HIR lowering
    let mut lowering = fwgsl_ast_lowering::AstLowering::new(&analyzer);
    let hir = lowering.lower_program(&program);

    if lowering.has_errors() {
        eprintln!("error: HIR lowering failed");
        process::exit(1);
    }

    // HIR -> MIR lowering
    let mir = match fwgsl_mir::lower::lower_hir_to_mir(&hir) {
        Ok(mir) => mir,
        Err(errors) => {
            for e in &errors {
                eprintln!("error: {}", e);
            }
            process::exit(1);
        }
    };

    // MIR -> WGSL codegen
    let wgsl = fwgsl_wgsl_codegen::emit_wgsl(&mir);

    println!(
        "// Generated by fwgsl compiler v{}",
        env!("CARGO_PKG_VERSION")
    );
    println!("// Source: {}", file);
    println!();
    print!("{}", wgsl);
}

fn cmd_check(file: &str) {
    let source = read_file(file);

    let mut parser = fwgsl_parser::parser::Parser::new(&source);
    let program = parser.parse_program();

    let mut has_errors = false;

    if parser.diagnostics().has_errors() {
        print_diagnostics(
            &parser.diagnostics().iter().collect::<Vec<_>>(),
            file,
            &source,
        );
        has_errors = true;
    }

    let mut analyzer = fwgsl_semantic::SemanticAnalyzer::new();
    analyzer.analyze(&program);

    if analyzer.has_errors() {
        let diags: Vec<_> = analyzer.diagnostics().iter().collect();
        print_diagnostics(&diags, file, &source);
        has_errors = true;
    }

    if has_errors {
        process::exit(1);
    } else {
        println!("No errors found in {}", file);
    }
}

fn cmd_fmt(file: &str) {
    let source = read_file(file);
    // TODO: Implement formatter
    // For now, just print the source back
    print!("{}", source);
}

fn read_file(path: &str) -> String {
    fs::read_to_string(path).unwrap_or_else(|e| {
        eprintln!("Error reading {}: {}", path, e);
        process::exit(1);
    })
}

fn print_diagnostics(diagnostics: &[&fwgsl_diagnostics::Diagnostic], file: &str, source: &str) {
    for diag in diagnostics {
        let severity = match diag.severity {
            fwgsl_diagnostics::Severity::Error => "error",
            fwgsl_diagnostics::Severity::Warning => "warning",
            fwgsl_diagnostics::Severity::Info => "info",
            fwgsl_diagnostics::Severity::Hint => "hint",
        };

        // Find line/col from first label span
        let location = if let Some(label) = diag.labels.first() {
            let (line, col) = offset_to_line_col(source, label.span.start as usize);
            format!("{}:{}:{}", file, line, col)
        } else {
            file.to_string()
        };

        eprintln!("{}: {}: {}", location, severity, diag.message);

        if let Some(ref help) = diag.help {
            eprintln!("  help: {}", help);
        }
    }
}

fn offset_to_line_col(source: &str, offset: usize) -> (usize, usize) {
    let mut line = 1;
    let mut col = 1;
    for (i, ch) in source.char_indices() {
        if i >= offset {
            break;
        }
        if ch == '\n' {
            line += 1;
            col = 1;
        } else {
            col += 1;
        }
    }
    (line, col)
}
